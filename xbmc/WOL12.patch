From fe4e14ede10904900b917f8486217a51c01cb0bc Mon Sep 17 00:00:00 2001
From: "t4.ravenbird" <t4.ravenbird@gmail.com>
Date: Mon, 25 Feb 2013 08:57:50 +0100
Subject: [PATCH] wake on access

---
 XBMC-ATV2.xcodeproj/project.pbxproj         |    6 +
 XBMC-IOS.xcodeproj/project.pbxproj          |    6 +
 XBMC.xcodeproj/project.pbxproj              |    6 +
 language/English/strings.po                 |   46 +-
 project/VS2010Express/XBMC.vcxproj          |    2 +
 project/VS2010Express/XBMC.vcxproj.filters  |    6 +
 xbmc/Application.cpp                        |   28 +-
 xbmc/Application.h                          |    1 +
 xbmc/dbwrappers/mysqldataset.cpp            |    3 +
 xbmc/filesystem/DirectoryFactory.cpp        |    2 +
 xbmc/filesystem/FileFactory.cpp             |    3 +
 xbmc/main/main.cpp                          |    7 -
 xbmc/network/Makefile.in                    |    1 +
 xbmc/network/Network.cpp                    |  117 +++++
 xbmc/network/Network.h                      |    6 +
 xbmc/network/WakeOnAccess.cpp               |  679 +++++++++++++++++++++++++++
 xbmc/network/WakeOnAccess.h                 |   80 ++++
 xbmc/network/linux/NetworkLinux.cpp         |  119 +++++
 xbmc/network/linux/NetworkLinux.h           |    5 +
 xbmc/network/osx/ioshacks.h                 |   70 +++
 xbmc/network/windows/NetworkWin32.cpp       |   54 +++
 xbmc/network/windows/NetworkWin32.h         |    5 +
 xbmc/settings/GUISettings.cpp               |    1 +
 xbmc/settings/GUIWindowSettingsCategory.cpp |    7 +
 xbmc/settings/Settings.cpp                  |    6 +
 25 files changed, 1251 insertions(+), 15 deletions(-)
 create mode 100644 xbmc/network/WakeOnAccess.cpp
 create mode 100644 xbmc/network/WakeOnAccess.h
 create mode 100644 xbmc/network/osx/ioshacks.h

diff --git a/language/English/strings.po b/language/English/strings.po
index 5b79b46..a2d287b 100644
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -4478,7 +4478,51 @@ msgctxt "#13025"
 msgid "Joystick unplugged"
 msgstr ""
 
-#empty strings from id 13026 to 13049
+msgctxt "#13026"
+msgid "Try to wake remote servers on access"
+msgstr ""
+
+msgctxt "#13027"
+msgid "Wake on Lan (%s)"
+msgstr ""
+
+msgctxt "#13028"
+msgid "Waiting for network to connect..."
+msgstr ""
+
+msgctxt "#13029"
+msgid "Failed to execute Wake on Lan!"
+msgstr ""
+
+msgctxt "#13030"
+msgid "Waiting for server to wake up..."
+msgstr ""
+
+msgctxt "#13031"
+msgid "Extended wait for server to wake up..."
+msgstr ""
+
+msgctxt "#13032"
+msgid "Waiting for services to launch..."
+msgstr ""
+
+msgctxt "#13033"
+msgid "MAC Discovery"
+msgstr ""
+
+msgctxt "#13034"
+msgid "Updated for %s"
+msgstr ""
+
+msgctxt "#13035"
+msgid "Found for %s"
+msgstr ""
+
+msgctxt "#13036"
+msgid "Failed for %s"
+msgstr ""
+
+#empty strings from id 13037 to 13049
 
 msgctxt "#13050"
 msgid "Running low on battery"
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 4afcf60..b8acf45 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -5058,17 +5058,23 @@ void CApplication::Process()
   // dispatch the messages generated by python or other threads to the current window
   g_windowManager.DispatchThreadMessages();
 
-  // process messages which have to be send to the gui
-  // (this can only be done after g_windowManager.Render())
-  CApplicationMessenger::Get().ProcessWindowMessages();
+  // only do full processing when m_slowTimer running
+  // if stopped, do a minimum and avoid anything causing file or db access
+  if (m_slowTimer.IsRunning())
+  {
+    // process messages which have to be send to the gui
+    // (this can only be done after g_windowManager.Render())
+    CApplicationMessenger::Get().ProcessWindowMessages();
 
 #ifdef HAS_PYTHON
-  // process any Python scripts
-  g_pythonParser.Process();
+    // process any Python scripts
+    g_pythonParser.Process();
 #endif
 
-  // process messages, even if a movie is playing
-  CApplicationMessenger::Get().ProcessMessages();
+    // process messages, even if a movie is playing
+    CApplicationMessenger::Get().ProcessMessages();
+  }
+
   if (g_application.m_bStop) return; //we're done, everything has been unloaded
 
   // check how far we are through playing the current item
@@ -5089,6 +5095,14 @@ void CApplication::Process()
   g_cpuInfo.getUsedPercentage(); // must call it to recalculate pct values
 }
 
+void CApplication::ProcessSlowEnable(bool enable)
+{
+  if (enable)
+    m_slowTimer.Start();
+  else
+    m_slowTimer.Stop();
+}
+
 // We get called every 500ms
 void CApplication::ProcessSlow()
 {
diff --git a/xbmc/Application.h b/xbmc/Application.h
index 3195c49..35dc562 100644
--- a/xbmc/Application.h
+++ b/xbmc/Application.h
@@ -208,6 +208,7 @@ class CApplication : public CXBApplicationEx, public IPlayerCallback, public IMs
 
   virtual void Process();
   void ProcessSlow();
+  void ProcessSlowEnable(bool enable);
   void ResetScreenSaver();
   int GetVolume() const;
   void SetVolume(float iValue, bool isPercentage = true);
diff --git a/xbmc/dbwrappers/mysqldataset.cpp b/xbmc/dbwrappers/mysqldataset.cpp
index d4cd153..07f3875 100644
--- a/xbmc/dbwrappers/mysqldataset.cpp
+++ b/xbmc/dbwrappers/mysqldataset.cpp
@@ -24,6 +24,7 @@
 
 #include "utils/log.h"
 #include "system.h" // for GetLastError()
+#include "network/WakeOnAccess.h"
 
 #ifdef HAS_MYSQL
 #include "mysqldataset.h"
@@ -119,6 +120,8 @@ int MysqlDatabase::connect(bool create_new) {
     if (conn == NULL)
       conn = mysql_init(conn);
 
+    CWakeOnAccess::Get().WakeUpHost(host, "MySQL : " + db);
+
     // establish connection with just user credentials
     if (mysql_real_connect(conn, host.c_str(),login.c_str(),passwd.c_str(), NULL, atoi(port.c_str()),NULL,0) != NULL)
     {
diff --git a/xbmc/filesystem/DirectoryFactory.cpp b/xbmc/filesystem/DirectoryFactory.cpp
index 0f5c393..3a2db9c 100644
--- a/xbmc/filesystem/DirectoryFactory.cpp
+++ b/xbmc/filesystem/DirectoryFactory.cpp
@@ -44,6 +44,7 @@
 #include "Application.h"
 #include "addons/Addon.h"
 #include "utils/log.h"
+#include "network/WakeOnAccess.h"
 
 #ifdef HAS_FILESYSTEM_SMB
 #ifdef _WIN32
@@ -124,6 +125,7 @@
 IDirectory* CDirectoryFactory::Create(const CStdString& strPath)
 {
   CURL url(strPath);
+  CWakeOnAccess::Get().WakeUpHost(url);
 
   CFileItem item(strPath, false);
   IFileDirectory* pDir=CFileDirectoryFactory::Create(strPath, &item);
diff --git a/xbmc/filesystem/FileFactory.cpp b/xbmc/filesystem/FileFactory.cpp
index 1483e31..466d3d3 100644
--- a/xbmc/filesystem/FileFactory.cpp
+++ b/xbmc/filesystem/FileFactory.cpp
@@ -96,6 +96,7 @@
 #include "Application.h"
 #include "URL.h"
 #include "utils/log.h"
+#include "network/WakeOnAccess.h"
 
 using namespace XFILE;
 
@@ -115,6 +116,8 @@ IFile* CFileFactory::CreateLoader(const CStdString& strFileName)
 
 IFile* CFileFactory::CreateLoader(const CURL& url)
 {
+  CWakeOnAccess::Get().WakeUpHost(url);
+
   CStdString strProtocol = url.GetProtocol();
   strProtocol.MakeLower();
 
diff --git a/xbmc/main/main.cpp b/xbmc/main/main.cpp
index 4ee13c3..319bc0e 100644
--- a/xbmc/main/main.cpp
+++ b/xbmc/main/main.cpp
@@ -66,13 +66,6 @@ int main(int argc, char* argv[])
   if (setrlimit(RLIMIT_CORE, &rlim) == -1)
     CLog::Log(LOGDEBUG, "Failed to set core size limit (%s)", strerror(errno));
 #endif
-  // Prevent child processes from becoming zombies on exit if not waited upon. See also Util::Command
-  struct sigaction sa;
-  memset(&sa, 0, sizeof(sa));
-
-  sa.sa_flags = SA_NOCLDWAIT;
-  sa.sa_handler = SIG_IGN;
-  sigaction(SIGCHLD, &sa, NULL);
 #endif
   setlocale(LC_NUMERIC, "C");
   g_advancedSettings.Initialize();
diff --git a/xbmc/network/Makefile.in b/xbmc/network/Makefile.in
index e2ffb0b..4e680fc 100644
--- a/xbmc/network/Makefile.in
+++ b/xbmc/network/Makefile.in
@@ -9,6 +9,7 @@ SRCS += Network.cpp
 SRCS += Socket.cpp
 SRCS += TCPServer.cpp
 SRCS += UdpClient.cpp
+SRCS += WakeOnAccess.cpp
 SRCS += WebServer.cpp
 SRCS += ZeroconfBrowser.cpp
 SRCS += Zeroconf.cpp
diff --git a/xbmc/network/Network.cpp b/xbmc/network/Network.cpp
index 976056a..4ee4fc0 100644
--- a/xbmc/network/Network.cpp
+++ b/xbmc/network/Network.cpp
@@ -279,6 +279,123 @@ bool CNetwork::WakeOnLan(const char* mac)
   return true;
 }
 
+// ping helper
+static const char* ConnectHostPort(SOCKET soc, const struct sockaddr_in& addr, struct timeval& timeOut, bool tryRead)
+{
+  // set non-blocking
+#ifdef _MSC_VER
+  u_long nonblocking = 1;
+  int result = ioctlsocket(soc, FIONBIO, &nonblocking);
+#else
+  int result = fcntl(soc, F_SETFL, fcntl(soc, F_GETFL) | O_NONBLOCK);
+#endif
+
+  if (result != 0)
+    return "set non-blocking option failed";
+
+  result = connect(soc, (struct sockaddr *)&addr, sizeof(addr)); // non-blocking connect, will fail ..
+
+  if (result < 0)
+  {
+#ifdef _MSC_VER
+    if (WSAGetLastError() != WSAEWOULDBLOCK)
+#else
+    if (errno != EINPROGRESS)
+#endif
+      return "unexpected connect fail";
+
+    { // wait for connect to complete
+      fd_set wset;
+      FD_ZERO(&wset); 
+      FD_SET(soc, &wset); 
+
+      result = select(FD_SETSIZE, 0, &wset, 0, &timeOut);
+    }
+
+    if (result < 0)
+      return "select fail";
+
+    if (result == 0) // timeout
+      return ""; // no error
+
+    { // verify socket connection state
+      int err_code = -1;
+      socklen_t code_len = sizeof (err_code);
+
+      result = getsockopt(soc, SOL_SOCKET, SO_ERROR, (char*) &err_code, &code_len);
+
+      if (result != 0)
+        return "getsockopt fail";
+
+      if (err_code != 0)
+        return ""; // no error, just not connected
+    }
+  }
+
+  if (tryRead)
+  {
+    fd_set rset;
+    FD_ZERO(&rset); 
+    FD_SET(soc, &rset); 
+
+    result = select(FD_SETSIZE, &rset, 0, 0, &timeOut);
+
+    if (result > 0)
+    {
+      char message [32];
+
+      result = recv(soc, message, sizeof(message), 0);
+    }
+
+    if (result == 0)
+      return ""; // no reply yet
+
+    if (result < 0)
+      return "recv fail";
+  }
+
+  return 0; // success
+}
+
+bool CNetwork::PingHost(unsigned long ipaddr, unsigned short port, unsigned int timeOutMs, bool readability_check)
+{
+  if (port == 0) // use icmp ping
+    return PingHost (ipaddr, timeOutMs);
+
+  struct sockaddr_in addr; 
+  addr.sin_family = AF_INET; 
+  addr.sin_port = htons(port); 
+  addr.sin_addr.s_addr = ipaddr; 
+
+  SOCKET soc = socket(AF_INET, SOCK_STREAM, 0); 
+
+  const char* err_msg = "invalid socket";
+
+  if (soc != INVALID_SOCKET)
+  {
+    struct timeval tmout; 
+    tmout.tv_sec = timeOutMs / 1000; 
+    tmout.tv_usec = (timeOutMs % 1000) * 1000; 
+
+    err_msg = ConnectHostPort (soc, addr, tmout, readability_check);
+
+    (void) closesocket (soc);
+  }
+
+  if (err_msg && *err_msg)
+  {
+#ifdef _MSC_VER
+    CStdString sock_err = WUSysMsg(WSAGetLastError());
+#else
+    CStdString sock_err = strerror(errno);
+#endif
+
+    CLog::Log(LOGERROR, "%s(%s:%d) - %s (%s)", __FUNCTION__, inet_ntoa(addr.sin_addr), port, err_msg, sock_err.c_str());
+  }
+
+  return err_msg == 0;
+}
+
 void CNetwork::StartServices()
 {
 #ifdef HAS_WEB_SERVER
diff --git a/xbmc/network/Network.h b/xbmc/network/Network.h
index 3f2bdf3..69411f8 100644
--- a/xbmc/network/Network.h
+++ b/xbmc/network/Network.h
@@ -62,6 +62,8 @@ class CNetworkInterface
    virtual CStdString GetMacAddress(void) = 0;
    virtual void GetMacAddressRaw(char rawMac[6]) = 0;
 
+   virtual bool GetHostMacAddress(unsigned long host, CStdString& mac) = 0;
+
    virtual CStdString GetCurrentIPAddress() = 0;
    virtual CStdString GetCurrentNetmask() = 0;
    virtual CStdString GetCurrentDefaultGateway(void) = 0;
@@ -110,6 +112,10 @@ class CNetwork
    // Return true if the magic packet was send
    bool WakeOnLan(const char *mac);
 
+   // Return true if host replies to ping
+   bool PingHost(unsigned long host, unsigned short port, unsigned int timeout_ms = 2000, bool readability_check = false);
+   virtual bool PingHost(unsigned long host, unsigned int timeout_ms = 2000) = 0;
+
    // Get/set the nameserver(s)
    virtual std::vector<CStdString> GetNameServers(void) = 0;
    virtual void SetNameServers(std::vector<CStdString> nameServers) = 0;
diff --git a/xbmc/network/WakeOnAccess.cpp b/xbmc/network/WakeOnAccess.cpp
new file mode 100644
index 0000000..b9ac0e5
--- /dev/null
+++ b/xbmc/network/WakeOnAccess.cpp
@@ -0,0 +1,679 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <limits.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include "system.h"
+#include "network/Network.h"
+#include "Application.h"
+#include "DNSNameCache.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "filesystem/SpecialProtocol.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/LocalizeStrings.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "utils/JobManager.h"
+#include "utils/log.h"
+#include "utils/XMLUtils.h"
+
+#include "WakeOnAccess.h"
+
+using namespace std;
+
+#define DEFAULT_NETWORK_INIT_SEC      (20)   // wait 20 sec for network after startup or resume
+#define DEFAULT_NETWORK_SETTLE_MS     (500)  // require 500ms of consistent network availability before trusting it
+
+#define DEFAULT_TIMEOUT_SEC (5*60)           // at least 5 minutes between each magic packets
+#define DEFAULT_WAIT_FOR_ONLINE_SEC_1 (40)   // wait at 40 seconds after sending magic packet
+#define DEFAULT_WAIT_FOR_ONLINE_SEC_2 (40)   // same for extended wait
+#define DEFAULT_WAIT_FOR_SERVICES_SEC (5)    // wait 5 seconds after host go online to launch file sharing deamons
+
+static int GetTotalSeconds(const CDateTimeSpan& ts)
+{
+  int hours = ts.GetHours() + ts.GetDays() * 24;
+  int minutes = ts.GetMinutes() + hours * 60;
+  return ts.GetSeconds() + minutes * 60;
+}
+
+static unsigned long HostToIP(const CStdString& host)
+{
+  CStdString ip;
+  CDNSNameCache::Lookup(host, ip);
+  return inet_addr(ip.c_str());
+}
+
+CWakeOnAccess::WakeUpEntry::WakeUpEntry (bool isAwake)
+  : timeout (0, 0, 0, DEFAULT_TIMEOUT_SEC)
+  , wait_online1_sec(DEFAULT_WAIT_FOR_ONLINE_SEC_1)
+  , wait_online2_sec(DEFAULT_WAIT_FOR_ONLINE_SEC_2)
+  , wait_services_sec(DEFAULT_WAIT_FOR_SERVICES_SEC)
+  , ping_port(0), ping_mode(0)
+{
+  nextWake = CDateTime::GetCurrentDateTime();
+
+  if (isAwake)
+    nextWake += timeout;
+}
+
+//**
+
+class CMACDiscoveryJob : public CJob
+{
+public:
+  CMACDiscoveryJob(const CStdString& host) : m_host(host) {}
+
+  virtual bool DoWork();
+
+  const CStdString& GetMAC() const { return m_macAddres; }
+  const CStdString& GetHost() const { return m_host; }
+
+private:
+  CStdString m_macAddres;
+  CStdString m_host;
+};
+
+bool CMACDiscoveryJob::DoWork()
+{
+  unsigned long ipAddress = HostToIP(m_host);
+
+  if (ipAddress == INADDR_NONE)
+  {
+    CLog::Log(LOGERROR, "%s - can't determine ip of '%s'", __FUNCTION__, m_host.c_str());
+    return false;
+  }
+
+  vector<CNetworkInterface*>& ifaces = g_application.getNetwork().GetInterfaceList();
+  for (vector<CNetworkInterface*>::const_iterator it = ifaces.begin(); it != ifaces.end(); ++it)
+  {
+    if ((*it)->GetHostMacAddress(ipAddress, m_macAddres))
+      return true;
+  }
+
+  return false;
+}
+
+//**
+
+class WaitCondition
+{
+public:
+  virtual bool SuccessWaiting () const { return false; }
+};
+
+class ProgressDialogHelper
+{
+public:
+  ProgressDialogHelper (const CStdString& heading) : m_dialog(0)
+  {
+    if (g_application.IsCurrentThread())
+      m_dialog = (CGUIDialogProgress*) g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS);
+
+    if (m_dialog)
+    {
+      m_dialog->SetHeading (heading); 
+      m_dialog->SetLine(0, "");
+      m_dialog->SetLine(1, "");
+      m_dialog->SetLine(2, "");
+      g_application.ProcessSlowEnable(false); // ProcessSlow will normally be done while dialog->Progress and may call back recursively to wake sleeping server !
+    }
+  }
+  ~ProgressDialogHelper ()
+  {
+    if (m_dialog)
+    {
+      m_dialog->Close();
+      g_application.ProcessSlowEnable(true);
+    }
+  }
+
+  bool HasDialog() const { return m_dialog != 0; }
+
+  enum wait_result { TimedOut, Canceled, Success };
+
+  wait_result ShowAndWait (const WaitCondition& waitObj, unsigned timeOutSec, const CStdString& line1)
+  {
+    unsigned timeOutMs = timeOutSec * 1000;
+
+    if (m_dialog)
+    {
+      m_dialog->SetLine(1, line1);
+
+      m_dialog->SetPercentage(1); // avoid flickering by starting at 1% ..
+    }
+
+    XbmcThreads::EndTime end_time (timeOutMs);
+
+    while (!end_time.IsTimePast())
+    {
+      if (waitObj.SuccessWaiting())
+        return Success;
+            
+      if (m_dialog)
+      {
+        if (!m_dialog->IsActive())
+          m_dialog->StartModal();
+
+        if (m_dialog->IsCanceled())
+          return Canceled;
+
+        m_dialog->Progress();
+
+        unsigned ms_passed = timeOutMs - end_time.MillisLeft();
+
+        int percentage = (ms_passed * 100) / timeOutMs;
+        m_dialog->SetPercentage(max(percentage, 1)); // avoid flickering , keep minimum 1%
+      }
+
+      Sleep (m_dialog ? 20 : 200);
+    }
+
+    return TimedOut;
+  }
+
+private:
+  CGUIDialogProgress* m_dialog;
+};
+
+class NetworkStartWaiter : public WaitCondition
+{
+public:
+  NetworkStartWaiter (unsigned settle_time_ms) : m_settle_time_ms (settle_time_ms)
+  {
+  }
+  virtual bool SuccessWaiting () const
+  {
+    CNetworkInterface* iface = g_application.getNetwork().GetFirstConnectedInterface();
+
+    bool online = iface && iface->IsEnabled();
+
+    if (!online) // setup endtime so we dont return true until network is consistently connected
+      m_end.Set (m_settle_time_ms);
+
+    return online && m_end.IsTimePast();
+  }
+private:
+  mutable XbmcThreads::EndTime m_end;
+  unsigned m_settle_time_ms;
+};
+
+class PingResponseWaiter : public WaitCondition, private IJobCallback
+{
+public:
+  PingResponseWaiter (bool async, const CWakeOnAccess::WakeUpEntry& server) 
+    : m_server(server), m_jobId(0), m_hostOnline(false)
+  {
+    if (async)
+    {
+      CJob* job = new CHostProberJob(this);
+      m_jobId = CJobManager::GetInstance().AddJob(job, this);
+    }
+  }
+  ~PingResponseWaiter()
+  {
+    CJobManager::GetInstance().CancelJob(m_jobId);
+  }
+  virtual bool SuccessWaiting () const
+  {
+    return m_jobId ? m_hostOnline : Ping();
+  }
+
+  virtual void OnJobComplete(unsigned int jobID, bool success, CJob *job)
+  {
+    m_hostOnline = success;
+  }
+
+  bool Ping () const
+  {
+    ULONG dst_ip = HostToIP(m_server.host);
+
+    return g_application.getNetwork().PingHost(dst_ip, m_server.ping_port, 2000, m_server.ping_mode & 1);
+  }
+
+private:
+  class CHostProberJob : public CJob
+  {
+    public:
+      CHostProberJob(const PingResponseWaiter* parent) : m_parent (parent) {}
+
+      virtual bool DoWork()
+      {
+        while (!ShouldCancel(0,0))
+        {
+          if (m_parent->Ping())
+            return true;
+        }
+        return false;
+      }
+
+    private:
+      const PingResponseWaiter* m_parent;
+  };
+
+  const CWakeOnAccess::WakeUpEntry& m_server;
+  unsigned int m_jobId;
+  bool m_hostOnline;
+};
+
+//
+
+class NestDetect
+{
+public:
+  NestDetect() : m_gui_thread (g_application.IsCurrentThread())
+  {
+    if (m_gui_thread)
+      ++m_nest;
+  }
+  ~NestDetect()
+  {
+    if (m_gui_thread)
+      m_nest--;
+  }
+  bool TooDeep() const
+  {
+    return m_gui_thread && m_nest > 1;
+  }
+
+private:
+  static int m_nest;
+  const bool m_gui_thread;
+};
+int NestDetect::m_nest = 0;
+
+//
+
+CWakeOnAccess::CWakeOnAccess()
+  : m_netinit_sec(DEFAULT_NETWORK_INIT_SEC)    // wait for network to connect
+  , m_netsettle_ms(DEFAULT_NETWORK_SETTLE_MS)  // wait for network to settle
+  , m_enabled(false)
+{
+}
+
+CWakeOnAccess &CWakeOnAccess::Get()
+{
+  static CWakeOnAccess sWakeOnAccess;
+  return sWakeOnAccess;
+}
+
+void CWakeOnAccess::WakeUpHost(const CURL& url)
+{
+  CStdString hostName = url.GetHostName();
+
+  if (!hostName.IsEmpty())
+    WakeUpHost (hostName, url.Get());
+}
+
+void CWakeOnAccess::WakeUpHost (const CStdString& hostName, const string& customMessage)
+{
+  if (!IsEnabled())
+    return; // bail if feature is turned off
+
+  for (EntriesVector::iterator i = m_entries.begin();i != m_entries.end(); ++i)
+  {
+    WakeUpEntry& server = *i;
+
+    if (hostName.Equals(server.host.c_str()))
+    {
+      CDateTime now = CDateTime::GetCurrentDateTime();
+
+      if (now > server.nextWake)
+      {
+        CLog::Log(LOGNOTICE,"WakeOnAccess [%s] trigged by accessing : %s", hostName.c_str(), customMessage.c_str());
+
+        NestDetect nesting ; // detect recursive calls on gui thread and bail out
+
+        if (nesting.TooDeep()) // we can not maintain progress-dialog if it gets called back in loop
+        {
+          CLog::Log(LOGERROR,"WakeOnAccess recursively called on gui-thread : aborting ");
+          return;
+        }
+
+        WakeUpHost(server);
+      }
+
+      server.nextWake = now + server.timeout;
+
+      return;
+    }
+  }
+}
+
+#define LOCALIZED(id) g_localizeStrings.Get(id)
+
+void CWakeOnAccess::WakeUpHost(const WakeUpEntry& server)
+{
+  CStdString heading = LOCALIZED(13027);
+  heading.Format (heading, server.host);
+
+  ProgressDialogHelper dlg (heading);
+
+  {
+    NetworkStartWaiter waitObj (m_netsettle_ms); // wait until network connected before sending wake-on-lan
+
+    if (dlg.ShowAndWait (waitObj, m_netinit_sec, LOCALIZED(13028)) != ProgressDialogHelper::Success)
+    {
+      CLog::Log(LOGNOTICE,"WakeOnAccess timeout/cancel while waiting for network");
+      return; // timedout or canceled
+    }
+  }
+
+  {
+    ULONG dst_ip = HostToIP(server.host);
+
+    if (g_application.getNetwork().PingHost(dst_ip, server.ping_port, 500)) // quick ping with short timeout to not block too long
+    {
+      CLog::Log(LOGNOTICE,"WakeOnAccess success exit, server already running");
+      return;
+    }
+  }
+
+  if (!g_application.getNetwork().WakeOnLan(server.mac.c_str()))
+  {
+    CLog::Log(LOGERROR,"WakeOnAccess failed to send. (Is it blocked by firewall?)");
+
+    if (g_application.IsCurrentThread() || !g_application.IsPlaying())
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, heading, LOCALIZED(13029));
+    return;
+  }
+
+  {
+    PingResponseWaiter waitObj (dlg.HasDialog(), server); // wait for ping response ..
+
+    ProgressDialogHelper::wait_result 
+      result = dlg.ShowAndWait (waitObj, server.wait_online1_sec, LOCALIZED(13030));
+
+    if (result == ProgressDialogHelper::TimedOut)
+      result = dlg.ShowAndWait (waitObj, server.wait_online2_sec, LOCALIZED(13031));
+
+    if (result != ProgressDialogHelper::Success)
+    {
+      CLog::Log(LOGNOTICE,"WakeOnAccess timeout/cancel while waiting for response");
+      return; // timedout or canceled
+    }
+  }
+
+  {
+    WaitCondition waitObj ; // wait uninteruptable fixed time for services ..
+
+    dlg.ShowAndWait (waitObj, server.wait_services_sec, LOCALIZED(13032));
+
+    CLog::Log(LOGNOTICE,"WakeOnAccess sequence completed, server started");
+  }
+}
+
+static void AddHost (const CStdString& host, vector<string>& hosts)
+{
+  for (vector<string>::const_iterator it = hosts.begin(); it != hosts.end(); ++it)
+    if (host.Equals((*it).c_str()))
+      return; // allready there ..
+
+  if (!host.IsEmpty())
+    hosts.push_back(host);
+}
+
+static void AddHostFromDatabase(const DatabaseSettings& setting, vector<string>& hosts)
+{
+  if (setting.type.Equals("mysql"))
+    AddHost(setting.host, hosts);
+}
+
+void CWakeOnAccess::QueueMACDiscoveryForHost(const CStdString& host)
+{
+  if (IsEnabled())
+    CJobManager::GetInstance().AddJob(new CMACDiscoveryJob(host), this);
+}
+
+void CWakeOnAccess::AddHostsFromShare(const CMediaSource& source, std::vector<std::string>& hosts)
+{
+  for (CStdStringArray::const_iterator it = source.vecPaths.begin() ; it != source.vecPaths.end(); it++)
+  {
+    CURL url = *it;
+
+    AddHost (url.GetHostName(), hosts);
+  }
+}
+
+void CWakeOnAccess::AddHostsFromShares(const VECSOURCES& sources, vector<string>& hosts)
+{
+  for (VECSOURCES::const_iterator it = sources.begin(); it != sources.end(); it++)
+    AddHostsFromShare(*it, hosts);
+}
+
+void CWakeOnAccess::QueueMACDiscoveryForShare(const CMediaSource& source)
+{
+  vector<string> hosts;
+  AddHostsFromShare(source, hosts);
+  for (vector<string>::const_iterator it = hosts.begin(); it != hosts.end(); it++)
+    QueueMACDiscoveryForHost(*it);
+}
+
+void CWakeOnAccess::QueueMACDiscoveryForAllRemotes()
+{
+  vector<string> hosts;
+
+  // add media sources
+  AddHostsFromShares(g_settings.m_videoSources, hosts);
+  AddHostsFromShares(g_settings.m_musicSources, hosts);
+  AddHostsFromShares(g_settings.m_pictureSources, hosts);
+  AddHostsFromShares(g_settings.m_fileSources, hosts);
+
+  // add mysql servers
+  AddHostFromDatabase(g_advancedSettings.m_databaseVideo, hosts);
+  AddHostFromDatabase(g_advancedSettings.m_databaseMusic, hosts);
+  AddHostFromDatabase(g_advancedSettings.m_databaseEpg, hosts);
+  AddHostFromDatabase(g_advancedSettings.m_databaseTV, hosts);
+
+  // add from path substitutions ..
+  for (CAdvancedSettings::StringMapping::iterator i = g_advancedSettings.m_pathSubstitutions.begin(); i != g_advancedSettings.m_pathSubstitutions.end(); ++i)
+  {
+    CURL url = i->second;
+
+    AddHost (url.GetHostName(), hosts);
+  }
+
+  for (vector<string>::const_iterator it = hosts.begin(); it != hosts.end(); it++)
+    QueueMACDiscoveryForHost(*it);
+}
+
+void CWakeOnAccess::OnJobComplete(unsigned int jobID, bool success, CJob *job)
+{
+  CMACDiscoveryJob* discoverJob = (CMACDiscoveryJob*)job;
+
+  CStdString heading = LOCALIZED(13033);
+
+  if (success)
+  {
+    CLog::Log(LOGNOTICE, "%s - Mac discovered for host '%s' -> '%s'", __FUNCTION__, discoverJob->GetHost().c_str(), discoverJob->GetMAC().c_str());
+    for (EntriesVector::iterator i = m_entries.begin(); i != m_entries.end(); ++i)
+    {
+      if (discoverJob->GetHost().Equals(i->host.c_str()))
+      {
+        CLog::Log(LOGDEBUG, "%s - Update existing entry for host '%s'", __FUNCTION__, discoverJob->GetHost().c_str());
+        if (!discoverJob->GetMAC().Equals(i->mac.c_str()))
+        {
+          if (IsEnabled()) // show notification only if we have general feature enabled
+          {
+            CStdString message = LOCALIZED(13034);
+            message.Format(message, discoverJob->GetHost());
+            CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, heading, message, 4000, true, 3000);
+          }
+
+          i->mac = discoverJob->GetMAC();
+          SaveToXML();
+        }
+
+        return;
+      }
+    }
+
+    // not found entry to update - create using default values
+    WakeUpEntry entry (true);
+    entry.host = discoverJob->GetHost();
+    entry.mac  = discoverJob->GetMAC();
+    m_entries.push_back(entry);
+
+    CLog::Log(LOGDEBUG, "%s - Create new entry for host '%s'", __FUNCTION__, discoverJob->GetHost().c_str());
+    if (IsEnabled()) // show notification only if we have general feature enabled
+    {
+      CStdString message = LOCALIZED(13035);
+      message.Format(message, discoverJob->GetHost());
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, heading, message, 4000, true, 3000);
+    }
+
+    SaveToXML();
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "%s - Mac discovery failed for host '%s'", __FUNCTION__, discoverJob->GetHost().c_str());
+
+    if (IsEnabled())
+    {
+      CStdString message = LOCALIZED(13036);
+      message.Format(message, discoverJob->GetHost());
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, heading, message, 4000, true, 3000);
+    }
+  }
+}
+
+CStdString CWakeOnAccess::GetSettingFile()
+{
+  return CSpecialProtocol::TranslatePath("special://masterprofile/wakeonlan.xml");
+}
+
+void CWakeOnAccess::LoadFromXML()
+{
+  SetEnabled(g_guiSettings.GetBool("powermanagement.wakeonaccess"));
+
+  CXBMCTinyXML xmlDoc;
+  if (!xmlDoc.LoadFile(GetSettingFile()))
+  {
+    CLog::Log(LOGNOTICE, "%s - unable to load:%s", __FUNCTION__, GetSettingFile().c_str());
+    return;
+  }
+
+  TiXmlElement* pRootElement = xmlDoc.RootElement();
+  if (strcmpi(pRootElement->Value(), "onaccesswakeup"))
+  {
+    CLog::Log(LOGERROR, "%s - XML file %s doesnt contain <onaccesswakeup>", __FUNCTION__, GetSettingFile().c_str());
+    return;
+  }
+
+  m_entries.clear();
+
+  CLog::Log(LOGNOTICE,"WakeOnAccess - Load settings :");
+
+  int tmp;
+  if (XMLUtils::GetInt(pRootElement, "netinittimeout", tmp, 0, 5 * 60))
+    m_netinit_sec = tmp;
+  CLog::Log(LOGNOTICE,"  -Network init timeout : [%d] sec", m_netinit_sec);
+  
+  if (XMLUtils::GetInt(pRootElement, "netsettletime", tmp, 0, 5 * 1000))
+    m_netsettle_ms = tmp;
+  CLog::Log(LOGNOTICE,"  -Network settle time  : [%d] ms", m_netsettle_ms);
+
+  const TiXmlNode* pWakeUp = pRootElement->FirstChildElement("wakeup");
+  while (pWakeUp)
+  {
+    WakeUpEntry entry;
+
+    CStdString strtmp;
+    if (XMLUtils::GetString(pWakeUp, "host", strtmp))
+      entry.host = strtmp;
+
+    if (XMLUtils::GetString(pWakeUp, "mac", strtmp))
+      entry.mac = strtmp;
+
+    if (entry.host.empty())
+      CLog::Log(LOGERROR, "%s - Missing <host> tag or it's empty", __FUNCTION__);
+    else if (entry.mac.empty())
+       CLog::Log(LOGERROR, "%s - Missing <mac> tag or it's empty", __FUNCTION__);
+    else
+    {
+      if (XMLUtils::GetInt(pWakeUp, "pingport", tmp, 0, USHRT_MAX))
+        entry.ping_port = (unsigned short) tmp;
+
+      if (XMLUtils::GetInt(pWakeUp, "pingmode", tmp, 0, USHRT_MAX))
+        entry.ping_mode = (unsigned short) tmp;
+
+      if (XMLUtils::GetInt(pWakeUp, "timeout", tmp, 10, 12 * 60 * 60))
+        entry.timeout.SetDateTimeSpan (0, 0, 0, tmp);
+
+      if (XMLUtils::GetInt(pWakeUp, "waitonline", tmp, 0, 10 * 60)) // max 10 minutes
+        entry.wait_online1_sec = tmp;
+
+      if (XMLUtils::GetInt(pWakeUp, "waitonline2", tmp, 0, 10 * 60)) // max 10 minutes
+        entry.wait_online2_sec = tmp;
+
+      if (XMLUtils::GetInt(pWakeUp, "waitservices", tmp, 0, 5 * 60)) // max 5 minutes
+        entry.wait_services_sec = tmp;
+
+      CLog::Log(LOGNOTICE,"  Registering wakeup entry:");
+      CLog::Log(LOGNOTICE,"    HostName        : %s", entry.host.c_str());
+      CLog::Log(LOGNOTICE,"    MacAddress      : %s", entry.mac.c_str());
+      CLog::Log(LOGNOTICE,"    PingPort        : %d", entry.ping_port);
+      CLog::Log(LOGNOTICE,"    PingMode        : %d", entry.ping_mode);
+      CLog::Log(LOGNOTICE,"    Timeout         : %d (sec)", GetTotalSeconds(entry.timeout));
+      CLog::Log(LOGNOTICE,"    WaitForOnline   : %d (sec)", entry.wait_online1_sec);
+      CLog::Log(LOGNOTICE,"    WaitForOnlineEx : %d (sec)", entry.wait_online2_sec);
+      CLog::Log(LOGNOTICE,"    WaitForServices : %d (sec)", entry.wait_services_sec);
+
+      m_entries.push_back(entry);
+    }
+
+    pWakeUp = pWakeUp->NextSiblingElement("wakeup"); // get next one
+  }
+}
+
+void CWakeOnAccess::SaveToXML()
+{
+  CXBMCTinyXML xmlDoc;
+  TiXmlElement xmlRootElement("onaccesswakeup");
+  TiXmlNode *pRoot = xmlDoc.InsertEndChild(xmlRootElement);
+  if (!pRoot) return;
+
+  XMLUtils::SetInt(pRoot, "netinittimeout", m_netinit_sec);
+  XMLUtils::SetInt(pRoot, "netsettletime", m_netsettle_ms);
+
+  for (EntriesVector::const_iterator i = m_entries.begin(); i != m_entries.end(); ++i)
+  {
+    TiXmlElement xmlSetting("wakeup");
+    TiXmlNode* pWakeUpNode = pRoot->InsertEndChild(xmlSetting);
+    if (pWakeUpNode)
+    {
+      XMLUtils::SetString(pWakeUpNode, "host", i->host);
+      XMLUtils::SetString(pWakeUpNode, "mac", i->mac);
+      XMLUtils::SetInt(pWakeUpNode, "pingport", i->ping_port);
+      XMLUtils::SetInt(pWakeUpNode, "pingmode", i->ping_mode);
+      XMLUtils::SetInt(pWakeUpNode, "timeout", GetTotalSeconds(i->timeout));
+      XMLUtils::SetInt(pWakeUpNode, "waitonline", i->wait_online1_sec);
+      XMLUtils::SetInt(pWakeUpNode, "waitonline2", i->wait_online2_sec);
+      XMLUtils::SetInt(pWakeUpNode, "waitservices", i->wait_services_sec);
+    }
+  }
+
+  xmlDoc.SaveFile(GetSettingFile());
+}
diff --git a/xbmc/network/WakeOnAccess.h b/xbmc/network/WakeOnAccess.h
new file mode 100644
index 0000000..2a1d853
--- /dev/null
+++ b/xbmc/network/WakeOnAccess.h
@@ -0,0 +1,80 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "URL.h"
+#include "MediaSource.h"
+#include "XBDateTime.h"
+#include "utils/Job.h"
+
+class CWakeOnAccess : public IJobCallback
+{
+public:
+  CWakeOnAccess();
+  static CWakeOnAccess &Get();
+
+  void WakeUpHost (const CURL& fileUrl);
+  void WakeUpHost (const CStdString& hostName, const std::string& customMessage);
+
+  void SetEnabled(bool enabled) { m_enabled = enabled; }
+  bool IsEnabled() const { return m_enabled; }
+
+  void QueueMACDiscoveryForHost(const CStdString& host);
+  void QueueMACDiscoveryForShare(const CMediaSource& source);
+  void QueueMACDiscoveryForAllRemotes();
+
+  virtual void OnJobComplete(unsigned int jobID, bool success, CJob *job);
+
+  void LoadFromXML();
+
+  // struct to keep per host settings
+  struct WakeUpEntry
+  {
+    WakeUpEntry (bool isAwake = false);
+
+    std::string host;
+    std::string mac;
+    CDateTimeSpan timeout;
+    unsigned int wait_online1_sec; // initial wait
+    unsigned int wait_online2_sec; // extended wait
+    unsigned int wait_services_sec;
+
+    unsigned short ping_port; // where to ping
+    unsigned short ping_mode; // how to ping
+
+    CDateTime nextWake;
+  };
+
+private:
+  void AddHostsFromShare(const CMediaSource& source, std::vector<std::string>& hosts);
+  void AddHostsFromShares(const VECSOURCES& sources, std::vector<std::string>& hosts);
+
+  CStdString GetSettingFile();
+  void SaveToXML();
+
+  typedef std::vector<WakeUpEntry> EntriesVector;
+  EntriesVector m_entries;
+
+  unsigned int m_netinit_sec, m_netsettle_ms; //time to wait for network connection
+
+  bool m_enabled;
+
+  void WakeUpHost(const WakeUpEntry& server);
+};
diff --git a/xbmc/network/linux/NetworkLinux.cpp b/xbmc/network/linux/NetworkLinux.cpp
index dc7ce84..108ce20 100644
--- a/xbmc/network/linux/NetworkLinux.cpp
+++ b/xbmc/network/linux/NetworkLinux.cpp
@@ -37,6 +37,13 @@
   #include <sys/sockio.h>
   #include <net/if.h>
   #include <net/if_dl.h>
+#if defined(TARGET_DARWIN_OSX)
+  #include <net/if_types.h>
+  #include <net/route.h>
+  #include <netinet/if_ether.h>
+#else //IOS
+  #include "network/osx/ioshacks.h"
+#endif
   #include <ifaddrs.h>
 #elif defined(TARGET_FREEBSD)
   #include <sys/sockio.h>
@@ -520,6 +527,118 @@ void CNetworkLinux::SetNameServers(std::vector<CStdString> nameServers)
 #endif
 }
 
+bool CNetworkLinux::PingHost(unsigned long remote_ip, unsigned int timeout_ms)
+{
+  char cmd_line [64];
+
+  struct in_addr host_ip; 
+  host_ip.s_addr = remote_ip;
+
+  sprintf(cmd_line, "ping -c 1 -w %d %s", timeout_ms / 1000 + (timeout_ms % 1000) != 0, inet_ntoa(host_ip));
+
+  int status = system (cmd_line);
+
+  int result = WIFEXITED(status) ? WEXITSTATUS(status) : -1;
+
+  // http://linux.about.com/od/commands/l/blcmdl8_ping.htm ;
+  // 0 reply
+  // 1 no reply
+  // else some error
+
+  if (result < 0 || result > 1)
+    CLog::Log(LOGERROR, "Ping fail : status = %d, errno = %d : '%s'", status, errno, cmd_line);
+
+  return result == 0;
+}
+
+#if defined TARGET_DARWIN
+bool CNetworkInterfaceLinux::GetHostMacAddress(unsigned long host_ip, CStdString& mac)
+{
+  bool ret = false;
+  size_t needed;
+  char *buf, *next;
+  struct rt_msghdr *rtm;
+  struct sockaddr_inarp *sin;
+  struct sockaddr_dl *sdl;
+  int mib[6];
+  
+  mac = "";
+  
+  mib[0] = CTL_NET;
+  mib[1] = PF_ROUTE;
+  mib[2] = 0;
+  mib[3] = AF_INET;
+  mib[4] = NET_RT_FLAGS;
+  mib[5] = RTF_LLINFO;
+  
+  if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), NULL, &needed, NULL, 0) == 0)
+  {   
+    if (buf = (char*)malloc(needed))
+    {      
+      if (sysctl(mib, sizeof(mib) / sizeof(mib[0]), buf, &needed, NULL, 0) == 0)
+      {        
+        for (next = buf; next < buf + needed; next += rtm->rtm_msglen) 
+        {
+          
+          rtm = (struct rt_msghdr *)next;
+          sin = (struct sockaddr_inarp *)(rtm + 1);
+          sdl = (struct sockaddr_dl *)(sin + 1);
+          
+          if (host_ip != sin->sin_addr.s_addr || sdl->sdl_alen < 6)
+            continue;
+          
+          u_char *cp = (u_char*)LLADDR(sdl);
+          
+          mac.Format("%02X:%02X:%02X:%02X:%02X:%02X",
+                     cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);
+          ret = true;
+          break;
+        }
+      }
+      free(buf);
+    }
+  }
+  return ret;
+}
+#else
+bool CNetworkInterfaceLinux::GetHostMacAddress(unsigned long host_ip, CStdString& mac)
+{
+  struct arpreq areq;
+  struct sockaddr_in* sin;
+
+  memset(&areq, 0x0, sizeof(areq));
+
+  sin = (struct sockaddr_in *) &areq.arp_pa;
+  sin->sin_family = AF_INET;
+  sin->sin_addr.s_addr = host_ip;
+
+  sin = (struct sockaddr_in *) &areq.arp_ha;
+  sin->sin_family = ARPHRD_ETHER;
+
+  strncpy(areq.arp_dev, m_interfaceName.c_str(), sizeof(areq.arp_dev));
+  areq.arp_dev[sizeof(areq.arp_dev)-1] = '\0';
+
+  int result = ioctl (m_network->GetSocket(), SIOCGARP, (caddr_t) &areq);
+
+  if (result != 0)
+  {
+//  CLog::Log(LOGERROR, "%s - GetHostMacAddress/ioctl failed with errno (%d)", __FUNCTION__, errno);
+    return false;
+  }
+
+  struct sockaddr* res = &areq.arp_ha;
+  mac.Format("%02X:%02X:%02X:%02X:%02X:%02X", 
+    (uint8_t) res->sa_data[0], (uint8_t) res->sa_data[1], (uint8_t) res->sa_data[2], 
+    (uint8_t) res->sa_data[3], (uint8_t) res->sa_data[4], (uint8_t) res->sa_data[5]);
+
+  for (int i=0; i<6; ++i)
+    if (res->sa_data[i])
+      return true;
+
+  return false;
+}
+#endif
+
 std::vector<NetworkAccessPoint> CNetworkInterfaceLinux::GetAccessPoints(void)
 {
    std::vector<NetworkAccessPoint> result;
diff --git a/xbmc/network/linux/NetworkLinux.h b/xbmc/network/linux/NetworkLinux.h
index 7031b6e..be4218e 100644
--- a/xbmc/network/linux/NetworkLinux.h
+++ b/xbmc/network/linux/NetworkLinux.h
@@ -42,6 +42,8 @@ class CNetworkInterfaceLinux : public CNetworkInterface
    virtual CStdString GetMacAddress(void);
    virtual void GetMacAddressRaw(char rawMac[6]);
 
+   virtual bool GetHostMacAddress(unsigned long host, CStdString& mac);
+
    virtual CStdString GetCurrentIPAddress();
    virtual CStdString GetCurrentNetmask();
    virtual CStdString GetCurrentDefaultGateway(void);
@@ -71,6 +73,9 @@ class CNetworkLinux : public CNetwork
    virtual std::vector<CNetworkInterface*>& GetInterfaceList(void);
    virtual CNetworkInterface* GetFirstConnectedInterface(void);        
     
+   // Ping remote host
+   virtual bool PingHost(unsigned long host, unsigned int timeout_ms = 2000);
+
    // Get/set the nameserver(s)
    virtual std::vector<CStdString> GetNameServers(void);
    virtual void SetNameServers(std::vector<CStdString> nameServers);
diff --git a/xbmc/network/osx/ioshacks.h b/xbmc/network/osx/ioshacks.h
new file mode 100644
index 0000000..c2c64ff
--- /dev/null
+++ b/xbmc/network/osx/ioshacks.h
@@ -0,0 +1,70 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+// needed for CNetworkInterfaceLinux::GetHostMacAddress and taken from osx sdk
+// net/if_types.h net/route.h netinet/if_ether.h
+
+/*
+ * These numbers are used by reliable protocols for determining
+ * retransmission behavior and are included in the routing structure.
+ */
+struct rt_metrics {
+	u_int32_t	rmx_locks;	/* Kernel must leave these values alone */
+	u_int32_t	rmx_mtu;	/* MTU for this path */
+	u_int32_t	rmx_hopcount;	/* max hops expected */
+	int32_t		rmx_expire;	/* lifetime for route, e.g. redirect */
+	u_int32_t	rmx_recvpipe;	/* inbound delay-bandwidth product */
+	u_int32_t	rmx_sendpipe;	/* outbound delay-bandwidth product */
+	u_int32_t	rmx_ssthresh;	/* outbound gateway buffer limit */
+	u_int32_t	rmx_rtt;	/* estimated round trip time */
+	u_int32_t	rmx_rttvar;	/* estimated rtt variance */
+	u_int32_t	rmx_pksent;	/* packets sent using this route */
+	u_int32_t	rmx_filler[4];	/* will be used for T/TCP later */
+};
+
+/*
+ * Structures for routing messages.
+ */
+struct rt_msghdr {
+	u_short	rtm_msglen;		/* to skip over non-understood messages */
+	u_char	rtm_version;		/* future binary compatibility */
+	u_char	rtm_type;		/* message type */
+	u_short	rtm_index;		/* index for associated ifp */
+	int	rtm_flags;		/* flags, incl. kern & message, e.g. DONE */
+	int	rtm_addrs;		/* bitmask identifying sockaddrs in msg */
+	pid_t	rtm_pid;		/* identify sender */
+	int	rtm_seq;		/* for sender to identify action */
+	int	rtm_errno;		/* why failed */
+	int	rtm_use;		/* from rtentry */
+	u_int32_t rtm_inits;		/* which metrics we are initializing */
+	struct rt_metrics rtm_rmx;	/* metrics themselves */
+};
+struct sockaddr_inarp {
+	u_char	sin_len;
+	u_char	sin_family;
+	u_short sin_port;
+	struct	in_addr sin_addr;
+	struct	in_addr sin_srcaddr;
+	u_short	sin_tos;
+	u_short	sin_other;
+#define SIN_PROXY 1
+};
+#define RTF_LLINFO	0x400		/* generated by link layer (e.g. ARP) */
+// --- END
diff --git a/xbmc/network/windows/NetworkWin32.cpp b/xbmc/network/windows/NetworkWin32.cpp
index f19a229..82fe5a8 100644
--- a/xbmc/network/windows/NetworkWin32.cpp
+++ b/xbmc/network/windows/NetworkWin32.cpp
@@ -19,6 +19,8 @@
  */
 
 #include <errno.h>
+#include <iphlpapi.h>
+#include <IcmpAPI.h>
 #include "PlatformDefs.h"
 #include "NetworkWin32.h"
 #include "utils/log.h"
@@ -261,6 +263,58 @@ void CNetworkWin32::SetNameServers(std::vector<CStdString> nameServers)
   return;
 }
 
+bool CNetworkWin32::PingHost(unsigned long host, unsigned int timeout_ms /* = 2000 */)
+{
+  char SendData[]    = "poke";
+  HANDLE hIcmpFile   = IcmpCreateFile();
+  BYTE ReplyBuffer [sizeof(ICMP_ECHO_REPLY) + sizeof(SendData)];
+
+  SetLastError(ERROR_SUCCESS);
+
+  DWORD dwRetVal = IcmpSendEcho(hIcmpFile, host, SendData, sizeof(SendData), 
+                                NULL, ReplyBuffer, sizeof(ReplyBuffer), timeout_ms);
+
+  DWORD lastErr = GetLastError();
+  if (lastErr != ERROR_SUCCESS)
+    CLog::Log(LOGERROR, "%s - IcmpSendEcho failed - %s", __FUNCTION__, WUSysMsg(lastErr).c_str());
+
+  IcmpCloseHandle (hIcmpFile);
+
+  if (dwRetVal != 0)
+  {
+    PICMP_ECHO_REPLY pEchoReply = (PICMP_ECHO_REPLY)ReplyBuffer;
+    return (pEchoReply->Status == IP_SUCCESS);
+  }
+  return false;
+}
+
+bool CNetworkInterfaceWin32::GetHostMacAddress(unsigned long host, CStdString& mac)
+{
+  IPAddr src_ip = inet_addr(GetCurrentIPAddress().c_str());
+  BYTE bPhysAddr[6];      // for 6-byte hardware addresses
+  ULONG PhysAddrLen = 6;  // default to length of six bytes
+
+  memset(&bPhysAddr, 0xff, sizeof (bPhysAddr));
+
+  DWORD dwRetVal = SendARP(host, src_ip, &bPhysAddr, &PhysAddrLen);
+  if (dwRetVal == NO_ERROR)
+  {
+    if (PhysAddrLen == 6)
+    {
+      mac.Format("%02X:%02X:%02X:%02X:%02X:%02X", 
+        bPhysAddr[0], bPhysAddr[1], bPhysAddr[2], 
+        bPhysAddr[3], bPhysAddr[4], bPhysAddr[5]);
+      return true;
+    }
+    else
+      CLog::Log(LOGERROR, "%s - SendArp completed successfully, but mac address has length != 6 (%d)", __FUNCTION__, PhysAddrLen);
+  }
+  else
+    CLog::Log(LOGERROR, "%s - SendArp failed with error (%d)", __FUNCTION__, dwRetVal);
+
+  return false;
+}
+
 std::vector<NetworkAccessPoint> CNetworkInterfaceWin32::GetAccessPoints(void)
 {
    std::vector<NetworkAccessPoint> result;
diff --git a/xbmc/network/windows/NetworkWin32.h b/xbmc/network/windows/NetworkWin32.h
index d163d8f..fd75508 100644
--- a/xbmc/network/windows/NetworkWin32.h
+++ b/xbmc/network/windows/NetworkWin32.h
@@ -45,6 +45,8 @@ class CNetworkInterfaceWin32 : public CNetworkInterface
    virtual CStdString GetMacAddress(void);
    virtual void GetMacAddressRaw(char rawMac[6]);
 
+   virtual bool GetHostMacAddress(unsigned long host, CStdString& mac);
+
    virtual CStdString GetCurrentIPAddress();
    virtual CStdString GetCurrentNetmask();
    virtual CStdString GetCurrentDefaultGateway(void);
@@ -72,6 +74,9 @@ class CNetworkWin32 : public CNetwork
    // Return the list of interfaces
    virtual std::vector<CNetworkInterface*>& GetInterfaceList(void);
 
+   // Ping remote host
+   virtual bool PingHost(unsigned long host, unsigned int timeout_ms = 2000);
+
    // Get/set the nameserver(s)
    virtual std::vector<CStdString> GetNameServers(void);
    virtual void SetNameServers(std::vector<CStdString> nameServers);
diff --git a/xbmc/settings/GUISettings.cpp b/xbmc/settings/GUISettings.cpp
index e92a82d..28b39f9 100644
--- a/xbmc/settings/GUISettings.cpp
+++ b/xbmc/settings/GUISettings.cpp
@@ -617,6 +617,7 @@ void CGUISettings::Initialize()
 #endif
     AddInt(pwm, "powermanagement.shutdownstate", 13008, POWERSTATE_QUIT, shutdown, SPIN_CONTROL_TEXT);
   }
+  AddBool(pwm, "powermanagement.wakeonaccess", 13026, false);
 
   CSettingsCategory* dbg = AddCategory(SETTINGS_SYSTEM, "debug", 14092);
   AddBool(dbg, "debug.showloginfo", 20191, false);
diff --git a/xbmc/settings/GUIWindowSettingsCategory.cpp b/xbmc/settings/GUIWindowSettingsCategory.cpp
index cb94f01..42fe65d 100644
--- a/xbmc/settings/GUIWindowSettingsCategory.cpp
+++ b/xbmc/settings/GUIWindowSettingsCategory.cpp
@@ -79,6 +79,7 @@
 #include "filesystem/SpecialProtocol.h"
 
 #include "network/Zeroconf.h"
+#include "network/WakeOnAccess.h"
 #include "peripherals/Peripherals.h"
 #include "peripherals/dialogs/GUIDialogPeripheralManager.h"
 #include "peripherals/devices/PeripheralImon.h"
@@ -1990,6 +1991,12 @@ void CGUIWindowSettingsCategory::OnSettingChanged(BaseSettingControlPtr pSetting
       }
     }
   }
+  else if (strSetting.Equals("powermanagement.wakeonaccess"))
+  {
+    CWakeOnAccess& woa = CWakeOnAccess::Get();
+    woa.SetEnabled (g_guiSettings.GetBool("powermanagement.wakeonaccess"));
+    woa.QueueMACDiscoveryForAllRemotes();
+  }
 
   UpdateSettings();
 }
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 3db721a..45fbe30 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -51,6 +51,7 @@
 #include "cores/playercorefactory/PlayerCoreFactory.h"
 #include "utils/FileUtils.h"
 #include "utils/URIUtils.h"
+#include "network/WakeOnAccess.h"
 #include "input/MouseStat.h"
 #include "filesystem/File.h"
 #include "filesystem/DirectoryCache.h"
@@ -179,6 +180,7 @@ bool CSettings::Load()
   LoadSources();
   LoadRSSFeeds();
   LoadUserFolderLayout();
+  CWakeOnAccess::Get().LoadFromXML();
 
   return true;
 }
@@ -1226,6 +1228,8 @@ bool CSettings::UpdateShare(const CStdString &type, const CStdString oldName, co
   if (!pShare)
     return false;
 
+  CWakeOnAccess::Get().QueueMACDiscoveryForShare(*pShare);
+
   // Update our XML file as well
   return SaveSources();
 }
@@ -1317,6 +1321,8 @@ bool CSettings::AddShare(const CStdString &type, const CMediaSource &share)
   }
   pShares->push_back(shareToAdd);
 
+  CWakeOnAccess::Get().QueueMACDiscoveryForShare(shareToAdd);
+
   if (!share.m_ignore)
   {
     return SaveSources();
-- 
1.7.10